defmodule IIV do
  @moduledoc """
  The Information Integrity Verification (IIV) module is responsible for verifying the correctness of
  information generated by the sub-symbolic AI. Besides that, it ensures that all necessary information
  is available for the AI to generate a valid llm_output.
  """

  alias PreProcessing.SymbolicPreProcessor
  alias PostProcessing.HybridPostProcessor

  @filename_categories Path.join([__DIR__, "resources", "cluster_filename_categories.json"])
  @metadata_keys Path.join([__DIR__, "resources", "meta_data_for_categories.json"])

  def pre_process_input_to_LLM(input_info) do
    input_info_updated = combine_meta_data(input_info)
    filename_class = classify_filename(input_info.title)

    result_verification =
      SymbolicPreProcessor.verify_LLM_input(
        input_info_updated,
        filename_class
      )
  end

  def post_process_content(input_info, output_content, mode, verifier_config) do
    case mode do
      :auto ->
        post_process_llm_output(input_info, output_content, verifier_config)

      :manual ->
        post_process_textarea_content(input_info, output_content, verifier_config)
    end
  end

  def post_process_llm_output(input_info, llm_output, verifier_config) do
    {device_and_basic_meta_data, parties_statements} =
      extract_single_meta_data(input_info.meta_data)

    chapter_info = if input_info.chapter_info == nil, do: nil, else: input_info.chapter_info

    previous_content =
      if input_info.previous_content == nil, do: nil, else: input_info.previous_content

    result_verification =
      HybridPostProcessor.post_process_llm_output(
        device_and_basic_meta_data,
        chapter_info,
        previous_content,
        parties_statements,
        llm_output,
        verifier_config
      )
  end

  def post_process_textarea_content(input_info, textarea_content, verifier_config) do
    {device_and_basic_meta_data, parties_statements} =
      extract_single_meta_data(input_info.meta_data)

    chapter_info = if input_info.chapter_info == nil, do: nil, else: input_info.chapter_info

    previous_content =
      if input_info.previous_content == nil, do: nil, else: input_info.previous_content

    result_verification =
      HybridPostProcessor.post_process_textarea_content(
        device_and_basic_meta_data,
        chapter_info,
        previous_content,
        parties_statements,
        textarea_content,
        verifier_config
      )
  end

  @doc """
  Extracts and combines "basic_info" and "device_info" from the metadata, and separately
  extracts "parties" information.

  Returns a tuple with:
    1. A map containing the combined basic_info and device_info (or nil if neither exists)
    2. The parties information (or nil if it doesn't exist)
  """
  def extract_single_meta_data(meta_data) do
    # Extract basic_info and device_info
    basic_info = meta_data["basic_info"] || %{}
    device_info = meta_data["device_info"] || %{}

    # Extract parties information
    parties = meta_data["parties"] || %{}

    # Combine basic_info and device_info
    combined_info = Map.merge(basic_info, device_info)

    # Return combined_info as nil if it's empty
    combined_info = if combined_info == %{}, do: nil, else: combined_info

    {combined_info, parties}
  end

  @deprecated
  def get_meta_data_for_categories(input_info) do
    title = input_info.title
    meta_data = input_info.meta_data
    title_categories = classify_filename(title)

    meta_data_keys_of_categories = extract_meta_data_keys(title_categories)

    # Flatten the list of meta data keys
    all_required_keys = List.flatten(meta_data_keys_of_categories)

    # Filter meta_data to include only key/value pairs where the key is in all_required_keys
    filtered_meta_data =
      meta_data
      |> Enum.filter(fn {key, _value} -> Enum.member?(all_required_keys, key) end)
      |> Map.new()

    # Update input_info with relevant meta data
    input_info_updated = Map.put(input_info, :meta_data, filtered_meta_data)

    IO.inspect(input_info_updated.meta_data, label: "Relevant Meta Data")
    input_info_updated
  end

  def sanitize_filename(filename) do
    # This pattern matches chapter numbering patterns like:
    # "3.1 ", "1.2.3 ", "1. ", etc. at the beginning of the string
    # It handles formats with or without spaces after periods
    sanitized_filename = Regex.replace(~r/^(\d+\.\s*)*\d+\.?\s*/, filename, "")
    # Remove potential ".md" file extension
    Regex.replace(~r/\.md$/, sanitized_filename, "")
  end

  @doc """
  Classifies a filename to determine which category it belongs to.
  Returns the first matching category name, or nil if no matches found.
  """
  def classify_filename(filename) do
    sanitized_filename = sanitize_filename(filename)

    try do
      case File.read(@filename_categories) do
        {:ok, categories_json} ->
          case Jason.decode(categories_json) do
            {:ok, categories} ->
              Enum.find_value(categories, nil, fn {category, filenames} ->
                if sanitized_filename in filenames, do: category, else: nil
              end)

            {:error, reason} ->
              IO.puts("Error decoding JSON: #{inspect(reason)}")
              nil
          end

        {:error, reason} ->
          IO.puts("Error reading categories file at #{@filename_categories}: #{inspect(reason)}")
          IO.puts("Current directory: #{File.cwd!()}")
          nil
      end
    rescue
      e ->
        IO.puts("Exception while classifying filename: #{inspect(e)}")
        nil
    end
  end

  def extract_meta_data_keys(title_categories) do
    # Read the metadata JSON file with proper error handling
    try do
      case File.read(@metadata_keys) do
        {:ok, metadata_json} ->
          case Jason.decode(metadata_json) do
            {:ok, metadata} ->
              # Look for exact matches of the filename in each category and collect all matches
              Enum.reduce(title_categories, [], fn category, acc ->
                # Check if the sanitized filename exactly matches any filename in the list
                if Map.has_key?(metadata, category) do
                  [metadata[category] | acc]
                else
                  acc
                end
              end)

            {:error, reason} ->
              IO.puts("Error decoding JSON: #{inspect(reason)}")
              []
          end

        {:error, reason} ->
          IO.puts("Error reading categories file at #{@metadata_keys}: #{inspect(reason)}")
          IO.puts("Current directory: #{File.cwd!()}")
          []
      end
    rescue
      e ->
        IO.puts("Exception while classifying filename: #{inspect(e)}")
        []
    end
  end

  @doc """
  Combines data from basic_info and device_info directly into meta_data without nested keys.
  The party key and its attributes remain untouched inside meta_data.
  """
  def combine_meta_data(input_info) do
    meta_data = input_info.meta_data || %{}
    basic_info = meta_data["basic_info"] || %{}
    device_info = meta_data["device_info"] || %{}
    parties = meta_data["parties"] || %{}

    # Create a new meta_data map with flattened structure
    # Start with basic_info content directly in meta_data
    new_meta_data =
      basic_info
      # Add device_info content directly in meta_data
      |> Map.merge(device_info)
      # Add back the party data if it exists
      |> (fn merged ->
            if parties, do: Map.put(merged, "parties", parties), else: merged
          end).()

    # Return the updated input_info with the new meta_data
    %{input_info | meta_data: new_meta_data}
  end
end
